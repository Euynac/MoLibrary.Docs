# 待办事项

## 模型验证
[ASP.NET Core MVC 中的模型验证 | Microsoft Learn](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/validation?view=aspnetcore-8.0)




## 测试

测试属性用户，此账号下所有操作犹如开启Debug模式，可看到错误堆栈等。
生产模式下，不会展示堆栈，但提供`traceId`


## 模块功能

### 运行时动态改变某个模块日志等级用于调试指定模块下功能


## 模块UI

### 自定义路由
ui 注册时，可以自定义路由，自定义路由实现是加入到路由字典，当 key 存在时，替换为 page 指定路径，page 路径根据静态字段维护，注册时可以获取对应映射关系

默认 page 路径规则改变为：
`/module/modulename/ui/feature name`

方案1：重定向中间件（推荐）

```cs
  // 创建路由重定向中间件
  public class UIRouteRedirectMiddleware(RequestDelegate next, IUIRouteConfigurationProvider routeProvider)
  {
      public async Task InvokeAsync(HttpContext context)
      {
          var path = context.Request.Path.Value;

          // 检查是否有路由映射
          foreach (var config in routeProvider.GetAllConfigurations())
          {
              if (path == config.CustomRoute)
              {
                  // 重定向到实际的组件路由
                  context.Request.Path = config.DefaultRoute;
                  break;
              }
          }

          await next(context);
      }
  }

```


修复路由问题：由于调整Configuration依赖Controller导致Controller模块提前初始化，导致后续执行的路由未能成功注册
增加这种检测机制？如果依赖的模块未能成功调用DependsOn说明有问题。


## nuget离线下载小工具

小工具可以配置如下功能：
1. 配置工作目录
2. 配置Nuget.exe路径
3. 设置目标框架，默认 .net 8
4. 配置离线包下载的目录
5. 支持配置私有源，默认官方源

主要功能：
1. 可识别配置目录下所有.csproj文件中包的依赖项，然后勾选需要下载的进度下载队列，有全部勾选及取消按钮
2. 可以手动输入包名以及版本
3. 配置完成后加入下载队列
4. 下载所有依赖项，包括隐式依赖的链条。
5. 下载过程中显示进度，下载到第几个包，有哪些包不存在。

注意事项：
1. 配置需要持久化本地文件如json
2. UI支持中英文切换

技术栈：
WPF + .NET 8， Fluent Design。

最后这是开源项目，需要以优秀开源项目的标准写README文档。

## 项目移动改名工具

现在我想要写一个python3脚本，用来更新.NET 解决方案的项目名或者进行项目移动，然后放到 @scripts/
  文件夹下，你需要建立新文件夹并写README。这个脚本要有的功能：
  脚本需要三个必填参数，
  1.要修改项目名的项目文件绝对路径
  2.workspace绝对路径，workspace是用来搜索所有相关路径
  3.新项目名（如果只有项目名则是改名，如果是绝对路径则需要判断是否还进行了项目文件夹移动）。

  脚本需要有良好的输出，比如当前状态，搜索到有哪些需要修改的文件，以及一些错误提示等等。

  实现方式是需要在workspace路径下搜索项目名，遍历所有sln、csproj文件等文件内容中有这个项目名的，找到这些影响项，记录下
  来，然后进行项目名以及项目文件夹名的修改（如果还有移动则还要进行移动），最后更新这些影响项的路径。

  请你输出README之外，还要输出项目需求文档，以便后续使用其他语言实现。

## 项目可观测性框架
通过队列单线程执行分析任务，分析任务异常的进行告警记录。

1. 异常统计、项目单元异常池，通过GlobalExceptionHandler分析堆栈信息解析到项目单元。
2. 执行耗时分析任务、总执行次数
3. 如依赖配置，则通过模拟获取此实例得到的配置值。

> 还有种方案是通过日志分析直接获取信息注入到项目单元



## 配置管理

  相关界面代码：@d:\Euynac\Programming\.NET\Euynac\MoLibrary\MoLibrary.Configuration.Dashboard\Pages\
  @d:\Euynac\Programming\.NET\Euynac\MoLibrary\MoLibrary.Configuration.Dashboard\UIConfiguration

  设计文档详见：@d:\Euynac\Programming\.NET\Euynac\MoLibrary.Docs\docs\Configuration\MoConfigurationDashboard.md
  注意查看新的MudBlazor迁移文档


#### 获取配置类类上默认值
通过 LocalJsonFileProvider 的 GetDefaultFileContents 获取



## Chart

目前，我们项目用K8S部署，但是还是分别用yaml文件管理的我们业务微服务，非常混乱，我们需要统一管理，因此考虑采用Helm Chart的方式去统一管理所有服务。

请你根据我们目前的yaml文件生成chart管理文件。我们需求：
1. 可以自定义命名空间，比如我们的系统需要部署在多个地方，每个地方的命名空间是不同的，比如zggg-fips-dev，或zhhh-fips-dev。然后生产的是zggg-fips-prod，所以需要自定义命名空间。
2. 自定义业务微服务appid的前缀，比如可以设定为 `zggg-dev`，或`zggg-uat`。
3. 我们微服务采用的dapr的微服务框架，yaml工作负载命名和dapr appid一致。我们的微服务appid参考 @global-appsettings.json，将当前yaml的微服务appid都同步成这个配置下的。
4. 我们想要可以批量添加配置到业务微服务yaml文件，比如统一的环境变量、挂载、资源限制、dapr边车相关配置等等。


注意，我们是Helm Chart的新手，所以你除了要写详细的注释外，还需要完成详细的介绍文档，以及使用文档，最好还要详细讲解Chart目录结构，是如何工作的。

相关文件路径：@scripts/k8s，其中services是我们业务微服务文件夹，other-components是依赖的某些第三方组件服务。




## 文件、文本公网传输工具

现在需求是开发一个轻量的公网文件、文本传输工具，因为现在有很多局域网的传输工具比如LocalSend，但有些情况又需要不同网络之间传输，现在没有什么好用的工具。所以需要开发一个。

[kern/filepizza: :pizza: Peer-to-peer file transfers in your browser](https://github.com/kern/filepizza/)
[schlagmichdoch/PairDrop: PairDrop: Transfer Files Cross-Platform. No Setup, No Signup.](https://github.com/schlagmichdoch/PairDrop)

技术难题：
WebRTC P2P方案（最高效）
  - 只需信令服务器交换连接信息
  - 数据直接在A、B间传输，不经过服务器
  - 核心技术：WebRTC DataChannel + STUN/TURN
不要把文件上传的到公网再下载下来，非常占用资源。
另外程序需要一个美观的界面：
1. 设置快捷键，开启监听剪切板内容，只需要两边打开此程序，可以快速在一台电脑复制、另一台粘贴。支持包括文件、文字等。支持多选复制。
2. 文件大小需要设置阈值，数量限制，超过需要人工确认复制和粘贴。
3. 传输过程中需要有进度条，展示当前文件传输进度、数量、预估时间、速度等。
4. 能够设置中心节点地址。
5. 所以可能需要一个Server端，其他是Client端。Server端支持Docker镜像部署。
6. 界面能看到当前在线的Client。
7. Server需要生成Token，Client填写Token，Server验证，才能变成有效Client，相同Token视作同一组可进行相互传输。
8. 支持开机自启动。

以优秀开源项目方式




## Markdown

现在需要新建一个新的MarkdownDocs模块，该模块主要是收集项目.md文档然后进行UI展示，能够搜索并通过界面展示文档。
该模块设计思路：
1. 首先需要扫描有哪些markdown文档并注册到文档管理服务中心。
2. 扫描器需要用户创建，在Guide类中增加一个方法可以接收markdown静态资源的路径+文档组（比如默认是wwwroot，用户传入`docs/*`），就是将该路径下的所有文档注册到指定文档组（比如`用户管理`)。文档组用于Markdwon 文档UI界面Tab，文档组对象可以接收用户配置Description（用于Tab hover上去的 tooltip 展示）
3. 提供文档服务接口：
	1. 列出所有文档，按照文档组+文档组内文档列表展示
	2. 通过文档名，返回文档相应访问路径（支持诸如`用户管理.md#权限控制`定位到指定标题）


## 客户端侧RPC

```
MoLibrary.Generators.AutoController 项目之前实现了Handler的自动接口生成， 我现在需要在其中增加一个生成 Client 侧RPC接口实现的代码的功能，具体是判断项目是否是使用了 AutoControllerGeneratorClientConfigAttribute 标签 （这些基础架构相关项目在 ../MoLibrary 下），要同时支持gRPC实现，目前先实现HTTP，预留gRPC扩展无需实现。

具体实现可以看当前手动实现的示例：
对于 Message 子域 
@IQueryMessage.cs   这是接口
@QueryMessageHttpApi.cs 这是实现  （有一部分没有手动实现的方法，实际上是要一并都实现的）

接口注意事项：
接口的命名规则：I{Command or Query}{DomainName}  
接口的注释使用相关的 Handler上的注释
方法定义都要有 [OperationContract] [MustUseReturnValue] 这两个特性
接口定义要有[ServiceContract]特性
接口的返回值、入参都对应相应Handler

实现注意事项：
实现的路由都参考相应的Handler的生成方式。
实现的基类要根据配置变化而变化
实现Http调用时根据Handler生成方式判断，如果是Get则使用Get方式调用，Post使用Post方式调用，以此类推。
Get方式的示例（有参，如无参则不需要使用ToQueryString()方法）：
 public async Task<Res<ResponseGetFlightRouteByFlightId>> GetFlightRouteByFlightId(QueryGetFlightRouteByFlightId query)
    {
        return await HttpClient.GetAsync($"api/v1/Message/flight-route-by-flight-id/{query.ToQueryString()}")
            .GetResponse<Res<ResponseGetFlightRouteByFlightId>>();
    }
POST方式的示例：
    public async Task<Res<ResponseTestDomainInvocation>> TestDomainInvocation(QueryTestDomainInvocation query)
    {
        return await HttpClient.PostAsJsonAsync("api/v1/Message/test", query)
            .GetResponse<Res<ResponseTestDomainInvocation>>();
    }

这个实现一个难点在于，能否从当前ProtocolPlatform项目Build时获取到其他Assembly，并扫描所有使用了[assembly:AutoControllerGeneratorConfig(DefaultRoutePrefix = "api/v1", DomainName = nameof(EServicesDomain.Message))] 的Assembly，这样才能去这里面获取相关Handler，并基于此来获取必要的信息来进行自动生成。
请你进行最小可行性验证，可以在SourceGenerator中打印日志到build output中来判断是否成功
```



## 主题优化

```markdown
 MoLibrary 主题优化指南

  背景信息

  MoLibrary 使用双层分离架构：C# 主题层负责颜色定义，CSS 层负责样式效果。目标是优化现有主题，遵循
  @rules\ui\mo-theme-css-style-guide.md 规范。

  优化流程

  1. 分析现有主题

  - 找到主题文件：MoLibrary.UI\Themes\Theme[主题名].cs 和 MoLibrary.UI\wwwroot\css\themes\mo-theme-[主题名].css
  - 识别问题：颜色对比度、CSS结构、动画效果、规范符合度

  2. CSS层优化原则

  关键原则：删除不必要的颜色覆盖，专注样式效果

  /* ❌ 错误：重复定义颜色 */
  .mud-button {
      background-color: var(--mud-palette-primary) !important;
      color: var(--mud-palette-primary-text) !important;
  }

  /* ✅ 正确：只定义样式效果 */
  .mud-button {
      border-radius: var(--mo-button-border-radius) !important;
      transition: var(--mo-button-transition) !important;
  }

  CSS优化要点：
  - 移除 background-color、color、border-color 等颜色属性
  - 保留圆角、间距、字体、动画等样式属性
  - 使用 var(--mud-palette-primary) 仅用于特效（如渐变、阴影）
  - 按规范组织变量：组件样式、间距、动画、特效

  3. C#层颜色优化重点

  关键文件结构：
  public class Theme[名称] : ThemeBase {
      public override MudTheme CreateTheme() {
          return new MudTheme() {
              PaletteLight = new PaletteLight() { /* 明亮模式颜色 */ },
              PaletteDark = new PaletteDark() { /* 暗色模式颜色 */ },
              Shadows = new Shadow() { /* 26个阴影级别 */ }
          };
      }
  }

  颜色优化要点：
  - 对比度是关键：特别注意暗色模式下 Primary 与 TextPrimary 的对比度
  - 语义化颜色：Info/Success/Warning/Error 要符合主题风格
  - 层次清晰：建立完整的灰度阶梯系统
  - 主题一致：颜色选择要符合主题的核心理念

  必须检查的对比度组合：
  - Primary vs TextPrimary (特别是暗色模式)
  - Surface vs TextPrimary
  - ActionDefault vs TextSecondary

  4. 常见问题修复

  动画效果过于浮夸：
  /* ❌ 避免复杂关键帧动画 */
  animation: mo-brush-stroke 0.3s ease-out;

  /* ✅ 使用简洁过渡 */
  transition: width var(--mo-transition-normal) ease;

  阴影系统优化：
  - 必须提供26个阴影级别（索引0-25）
  - 使用主题相关的颜色 rgba(主题色, 透明度)
  - 提供多层阴影模拟自然效果

  5. 验证清单

  - CSS中移除了不必要的颜色覆盖
  - 颜色对比度符合可访问性标准
  - 暗色模式Primary颜色与白色文字对比清晰
  - 动画效果自然不浮夸
  - 阴影数组包含26个元素
  - 主题风格一致性
  - 响应式和无障碍支持完整

  执行命令示例

  请你优化 [主题名] 主题：
  1. 按照规范重构CSS，删除不必要的颜色覆盖
  2. 优化C#层颜色定义，特别注意对比度问题
  3. 检查并优化动画效果，避免过于浮夸
  4. 确保符合 @rules\ui\mo-theme-css-style-guide.md 规范
```